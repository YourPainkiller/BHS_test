// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/YourPainkiller/BHS_test/internal/repository.Facade -o facade_mock.go -n FacadeMock -p mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/YourPainkiller/BHS_test/internal/dto"
	"github.com/gojuno/minimock/v3"
)

// FacadeMock implements mm_repository.Facade
type FacadeMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddAsset          func(ctx context.Context, req dto.AssetDto) (err error)
	funcAddAssetOrigin    string
	inspectFuncAddAsset   func(ctx context.Context, req dto.AssetDto)
	afterAddAssetCounter  uint64
	beforeAddAssetCounter uint64
	AddAssetMock          mFacadeMockAddAsset

	funcAddRefreshSession          func(ctx context.Context, req dto.RefreshSessionDto) (err error)
	funcAddRefreshSessionOrigin    string
	inspectFuncAddRefreshSession   func(ctx context.Context, req dto.RefreshSessionDto)
	afterAddRefreshSessionCounter  uint64
	beforeAddRefreshSessionCounter uint64
	AddRefreshSessionMock          mFacadeMockAddRefreshSession

	funcAddUser          func(ctx context.Context, req dto.UserDto) (err error)
	funcAddUserOrigin    string
	inspectFuncAddUser   func(ctx context.Context, req dto.UserDto)
	afterAddUserCounter  uint64
	beforeAddUserCounter uint64
	AddUserMock          mFacadeMockAddUser

	funcDeleteAsset          func(ctx context.Context, req dto.DeleteAssetDto) (err error)
	funcDeleteAssetOrigin    string
	inspectFuncDeleteAsset   func(ctx context.Context, req dto.DeleteAssetDto)
	afterDeleteAssetCounter  uint64
	beforeDeleteAssetCounter uint64
	DeleteAssetMock          mFacadeMockDeleteAsset

	funcGetAssetInfo          func(ctx context.Context, assetName string) (ap1 *dto.AssetDto, err error)
	funcGetAssetInfoOrigin    string
	inspectFuncGetAssetInfo   func(ctx context.Context, assetName string)
	afterGetAssetInfoCounter  uint64
	beforeGetAssetInfoCounter uint64
	GetAssetInfoMock          mFacadeMockGetAssetInfo

	funcGetUserByUsername          func(ctx context.Context, username string) (up1 *dto.UserDto, err error)
	funcGetUserByUsernameOrigin    string
	inspectFuncGetUserByUsername   func(ctx context.Context, username string)
	afterGetUserByUsernameCounter  uint64
	beforeGetUserByUsernameCounter uint64
	GetUserByUsernameMock          mFacadeMockGetUserByUsername

	funcRefresh          func(ctx context.Context, req dto.UpdateRefreshDto) (err error)
	funcRefreshOrigin    string
	inspectFuncRefresh   func(ctx context.Context, req dto.UpdateRefreshDto)
	afterRefreshCounter  uint64
	beforeRefreshCounter uint64
	RefreshMock          mFacadeMockRefresh
}

// NewFacadeMock returns a mock for mm_repository.Facade
func NewFacadeMock(t minimock.Tester) *FacadeMock {
	m := &FacadeMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddAssetMock = mFacadeMockAddAsset{mock: m}
	m.AddAssetMock.callArgs = []*FacadeMockAddAssetParams{}

	m.AddRefreshSessionMock = mFacadeMockAddRefreshSession{mock: m}
	m.AddRefreshSessionMock.callArgs = []*FacadeMockAddRefreshSessionParams{}

	m.AddUserMock = mFacadeMockAddUser{mock: m}
	m.AddUserMock.callArgs = []*FacadeMockAddUserParams{}

	m.DeleteAssetMock = mFacadeMockDeleteAsset{mock: m}
	m.DeleteAssetMock.callArgs = []*FacadeMockDeleteAssetParams{}

	m.GetAssetInfoMock = mFacadeMockGetAssetInfo{mock: m}
	m.GetAssetInfoMock.callArgs = []*FacadeMockGetAssetInfoParams{}

	m.GetUserByUsernameMock = mFacadeMockGetUserByUsername{mock: m}
	m.GetUserByUsernameMock.callArgs = []*FacadeMockGetUserByUsernameParams{}

	m.RefreshMock = mFacadeMockRefresh{mock: m}
	m.RefreshMock.callArgs = []*FacadeMockRefreshParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFacadeMockAddAsset struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockAddAssetExpectation
	expectations       []*FacadeMockAddAssetExpectation

	callArgs []*FacadeMockAddAssetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockAddAssetExpectation specifies expectation struct of the Facade.AddAsset
type FacadeMockAddAssetExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockAddAssetParams
	paramPtrs          *FacadeMockAddAssetParamPtrs
	expectationOrigins FacadeMockAddAssetExpectationOrigins
	results            *FacadeMockAddAssetResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockAddAssetParams contains parameters of the Facade.AddAsset
type FacadeMockAddAssetParams struct {
	ctx context.Context
	req dto.AssetDto
}

// FacadeMockAddAssetParamPtrs contains pointers to parameters of the Facade.AddAsset
type FacadeMockAddAssetParamPtrs struct {
	ctx *context.Context
	req *dto.AssetDto
}

// FacadeMockAddAssetResults contains results of the Facade.AddAsset
type FacadeMockAddAssetResults struct {
	err error
}

// FacadeMockAddAssetOrigins contains origins of expectations of the Facade.AddAsset
type FacadeMockAddAssetExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddAsset *mFacadeMockAddAsset) Optional() *mFacadeMockAddAsset {
	mmAddAsset.optional = true
	return mmAddAsset
}

// Expect sets up expected params for Facade.AddAsset
func (mmAddAsset *mFacadeMockAddAsset) Expect(ctx context.Context, req dto.AssetDto) *mFacadeMockAddAsset {
	if mmAddAsset.mock.funcAddAsset != nil {
		mmAddAsset.mock.t.Fatalf("FacadeMock.AddAsset mock is already set by Set")
	}

	if mmAddAsset.defaultExpectation == nil {
		mmAddAsset.defaultExpectation = &FacadeMockAddAssetExpectation{}
	}

	if mmAddAsset.defaultExpectation.paramPtrs != nil {
		mmAddAsset.mock.t.Fatalf("FacadeMock.AddAsset mock is already set by ExpectParams functions")
	}

	mmAddAsset.defaultExpectation.params = &FacadeMockAddAssetParams{ctx, req}
	mmAddAsset.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddAsset.expectations {
		if minimock.Equal(e.params, mmAddAsset.defaultExpectation.params) {
			mmAddAsset.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddAsset.defaultExpectation.params)
		}
	}

	return mmAddAsset
}

// ExpectCtxParam1 sets up expected param ctx for Facade.AddAsset
func (mmAddAsset *mFacadeMockAddAsset) ExpectCtxParam1(ctx context.Context) *mFacadeMockAddAsset {
	if mmAddAsset.mock.funcAddAsset != nil {
		mmAddAsset.mock.t.Fatalf("FacadeMock.AddAsset mock is already set by Set")
	}

	if mmAddAsset.defaultExpectation == nil {
		mmAddAsset.defaultExpectation = &FacadeMockAddAssetExpectation{}
	}

	if mmAddAsset.defaultExpectation.params != nil {
		mmAddAsset.mock.t.Fatalf("FacadeMock.AddAsset mock is already set by Expect")
	}

	if mmAddAsset.defaultExpectation.paramPtrs == nil {
		mmAddAsset.defaultExpectation.paramPtrs = &FacadeMockAddAssetParamPtrs{}
	}
	mmAddAsset.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddAsset.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddAsset
}

// ExpectReqParam2 sets up expected param req for Facade.AddAsset
func (mmAddAsset *mFacadeMockAddAsset) ExpectReqParam2(req dto.AssetDto) *mFacadeMockAddAsset {
	if mmAddAsset.mock.funcAddAsset != nil {
		mmAddAsset.mock.t.Fatalf("FacadeMock.AddAsset mock is already set by Set")
	}

	if mmAddAsset.defaultExpectation == nil {
		mmAddAsset.defaultExpectation = &FacadeMockAddAssetExpectation{}
	}

	if mmAddAsset.defaultExpectation.params != nil {
		mmAddAsset.mock.t.Fatalf("FacadeMock.AddAsset mock is already set by Expect")
	}

	if mmAddAsset.defaultExpectation.paramPtrs == nil {
		mmAddAsset.defaultExpectation.paramPtrs = &FacadeMockAddAssetParamPtrs{}
	}
	mmAddAsset.defaultExpectation.paramPtrs.req = &req
	mmAddAsset.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmAddAsset
}

// Inspect accepts an inspector function that has same arguments as the Facade.AddAsset
func (mmAddAsset *mFacadeMockAddAsset) Inspect(f func(ctx context.Context, req dto.AssetDto)) *mFacadeMockAddAsset {
	if mmAddAsset.mock.inspectFuncAddAsset != nil {
		mmAddAsset.mock.t.Fatalf("Inspect function is already set for FacadeMock.AddAsset")
	}

	mmAddAsset.mock.inspectFuncAddAsset = f

	return mmAddAsset
}

// Return sets up results that will be returned by Facade.AddAsset
func (mmAddAsset *mFacadeMockAddAsset) Return(err error) *FacadeMock {
	if mmAddAsset.mock.funcAddAsset != nil {
		mmAddAsset.mock.t.Fatalf("FacadeMock.AddAsset mock is already set by Set")
	}

	if mmAddAsset.defaultExpectation == nil {
		mmAddAsset.defaultExpectation = &FacadeMockAddAssetExpectation{mock: mmAddAsset.mock}
	}
	mmAddAsset.defaultExpectation.results = &FacadeMockAddAssetResults{err}
	mmAddAsset.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddAsset.mock
}

// Set uses given function f to mock the Facade.AddAsset method
func (mmAddAsset *mFacadeMockAddAsset) Set(f func(ctx context.Context, req dto.AssetDto) (err error)) *FacadeMock {
	if mmAddAsset.defaultExpectation != nil {
		mmAddAsset.mock.t.Fatalf("Default expectation is already set for the Facade.AddAsset method")
	}

	if len(mmAddAsset.expectations) > 0 {
		mmAddAsset.mock.t.Fatalf("Some expectations are already set for the Facade.AddAsset method")
	}

	mmAddAsset.mock.funcAddAsset = f
	mmAddAsset.mock.funcAddAssetOrigin = minimock.CallerInfo(1)
	return mmAddAsset.mock
}

// When sets expectation for the Facade.AddAsset which will trigger the result defined by the following
// Then helper
func (mmAddAsset *mFacadeMockAddAsset) When(ctx context.Context, req dto.AssetDto) *FacadeMockAddAssetExpectation {
	if mmAddAsset.mock.funcAddAsset != nil {
		mmAddAsset.mock.t.Fatalf("FacadeMock.AddAsset mock is already set by Set")
	}

	expectation := &FacadeMockAddAssetExpectation{
		mock:               mmAddAsset.mock,
		params:             &FacadeMockAddAssetParams{ctx, req},
		expectationOrigins: FacadeMockAddAssetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddAsset.expectations = append(mmAddAsset.expectations, expectation)
	return expectation
}

// Then sets up Facade.AddAsset return parameters for the expectation previously defined by the When method
func (e *FacadeMockAddAssetExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockAddAssetResults{err}
	return e.mock
}

// Times sets number of times Facade.AddAsset should be invoked
func (mmAddAsset *mFacadeMockAddAsset) Times(n uint64) *mFacadeMockAddAsset {
	if n == 0 {
		mmAddAsset.mock.t.Fatalf("Times of FacadeMock.AddAsset mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddAsset.expectedInvocations, n)
	mmAddAsset.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddAsset
}

func (mmAddAsset *mFacadeMockAddAsset) invocationsDone() bool {
	if len(mmAddAsset.expectations) == 0 && mmAddAsset.defaultExpectation == nil && mmAddAsset.mock.funcAddAsset == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddAsset.mock.afterAddAssetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddAsset.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddAsset implements mm_repository.Facade
func (mmAddAsset *FacadeMock) AddAsset(ctx context.Context, req dto.AssetDto) (err error) {
	mm_atomic.AddUint64(&mmAddAsset.beforeAddAssetCounter, 1)
	defer mm_atomic.AddUint64(&mmAddAsset.afterAddAssetCounter, 1)

	mmAddAsset.t.Helper()

	if mmAddAsset.inspectFuncAddAsset != nil {
		mmAddAsset.inspectFuncAddAsset(ctx, req)
	}

	mm_params := FacadeMockAddAssetParams{ctx, req}

	// Record call args
	mmAddAsset.AddAssetMock.mutex.Lock()
	mmAddAsset.AddAssetMock.callArgs = append(mmAddAsset.AddAssetMock.callArgs, &mm_params)
	mmAddAsset.AddAssetMock.mutex.Unlock()

	for _, e := range mmAddAsset.AddAssetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddAsset.AddAssetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddAsset.AddAssetMock.defaultExpectation.Counter, 1)
		mm_want := mmAddAsset.AddAssetMock.defaultExpectation.params
		mm_want_ptrs := mmAddAsset.AddAssetMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockAddAssetParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddAsset.t.Errorf("FacadeMock.AddAsset got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddAsset.AddAssetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmAddAsset.t.Errorf("FacadeMock.AddAsset got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddAsset.AddAssetMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddAsset.t.Errorf("FacadeMock.AddAsset got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddAsset.AddAssetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddAsset.AddAssetMock.defaultExpectation.results
		if mm_results == nil {
			mmAddAsset.t.Fatal("No results are set for the FacadeMock.AddAsset")
		}
		return (*mm_results).err
	}
	if mmAddAsset.funcAddAsset != nil {
		return mmAddAsset.funcAddAsset(ctx, req)
	}
	mmAddAsset.t.Fatalf("Unexpected call to FacadeMock.AddAsset. %v %v", ctx, req)
	return
}

// AddAssetAfterCounter returns a count of finished FacadeMock.AddAsset invocations
func (mmAddAsset *FacadeMock) AddAssetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAsset.afterAddAssetCounter)
}

// AddAssetBeforeCounter returns a count of FacadeMock.AddAsset invocations
func (mmAddAsset *FacadeMock) AddAssetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddAsset.beforeAddAssetCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.AddAsset.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddAsset *mFacadeMockAddAsset) Calls() []*FacadeMockAddAssetParams {
	mmAddAsset.mutex.RLock()

	argCopy := make([]*FacadeMockAddAssetParams, len(mmAddAsset.callArgs))
	copy(argCopy, mmAddAsset.callArgs)

	mmAddAsset.mutex.RUnlock()

	return argCopy
}

// MinimockAddAssetDone returns true if the count of the AddAsset invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockAddAssetDone() bool {
	if m.AddAssetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddAssetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddAssetMock.invocationsDone()
}

// MinimockAddAssetInspect logs each unmet expectation
func (m *FacadeMock) MinimockAddAssetInspect() {
	for _, e := range m.AddAssetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.AddAsset at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddAssetCounter := mm_atomic.LoadUint64(&m.afterAddAssetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddAssetMock.defaultExpectation != nil && afterAddAssetCounter < 1 {
		if m.AddAssetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.AddAsset at\n%s", m.AddAssetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.AddAsset at\n%s with params: %#v", m.AddAssetMock.defaultExpectation.expectationOrigins.origin, *m.AddAssetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddAsset != nil && afterAddAssetCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.AddAsset at\n%s", m.funcAddAssetOrigin)
	}

	if !m.AddAssetMock.invocationsDone() && afterAddAssetCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.AddAsset at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddAssetMock.expectedInvocations), m.AddAssetMock.expectedInvocationsOrigin, afterAddAssetCounter)
	}
}

type mFacadeMockAddRefreshSession struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockAddRefreshSessionExpectation
	expectations       []*FacadeMockAddRefreshSessionExpectation

	callArgs []*FacadeMockAddRefreshSessionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockAddRefreshSessionExpectation specifies expectation struct of the Facade.AddRefreshSession
type FacadeMockAddRefreshSessionExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockAddRefreshSessionParams
	paramPtrs          *FacadeMockAddRefreshSessionParamPtrs
	expectationOrigins FacadeMockAddRefreshSessionExpectationOrigins
	results            *FacadeMockAddRefreshSessionResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockAddRefreshSessionParams contains parameters of the Facade.AddRefreshSession
type FacadeMockAddRefreshSessionParams struct {
	ctx context.Context
	req dto.RefreshSessionDto
}

// FacadeMockAddRefreshSessionParamPtrs contains pointers to parameters of the Facade.AddRefreshSession
type FacadeMockAddRefreshSessionParamPtrs struct {
	ctx *context.Context
	req *dto.RefreshSessionDto
}

// FacadeMockAddRefreshSessionResults contains results of the Facade.AddRefreshSession
type FacadeMockAddRefreshSessionResults struct {
	err error
}

// FacadeMockAddRefreshSessionOrigins contains origins of expectations of the Facade.AddRefreshSession
type FacadeMockAddRefreshSessionExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) Optional() *mFacadeMockAddRefreshSession {
	mmAddRefreshSession.optional = true
	return mmAddRefreshSession
}

// Expect sets up expected params for Facade.AddRefreshSession
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) Expect(ctx context.Context, req dto.RefreshSessionDto) *mFacadeMockAddRefreshSession {
	if mmAddRefreshSession.mock.funcAddRefreshSession != nil {
		mmAddRefreshSession.mock.t.Fatalf("FacadeMock.AddRefreshSession mock is already set by Set")
	}

	if mmAddRefreshSession.defaultExpectation == nil {
		mmAddRefreshSession.defaultExpectation = &FacadeMockAddRefreshSessionExpectation{}
	}

	if mmAddRefreshSession.defaultExpectation.paramPtrs != nil {
		mmAddRefreshSession.mock.t.Fatalf("FacadeMock.AddRefreshSession mock is already set by ExpectParams functions")
	}

	mmAddRefreshSession.defaultExpectation.params = &FacadeMockAddRefreshSessionParams{ctx, req}
	mmAddRefreshSession.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddRefreshSession.expectations {
		if minimock.Equal(e.params, mmAddRefreshSession.defaultExpectation.params) {
			mmAddRefreshSession.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddRefreshSession.defaultExpectation.params)
		}
	}

	return mmAddRefreshSession
}

// ExpectCtxParam1 sets up expected param ctx for Facade.AddRefreshSession
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) ExpectCtxParam1(ctx context.Context) *mFacadeMockAddRefreshSession {
	if mmAddRefreshSession.mock.funcAddRefreshSession != nil {
		mmAddRefreshSession.mock.t.Fatalf("FacadeMock.AddRefreshSession mock is already set by Set")
	}

	if mmAddRefreshSession.defaultExpectation == nil {
		mmAddRefreshSession.defaultExpectation = &FacadeMockAddRefreshSessionExpectation{}
	}

	if mmAddRefreshSession.defaultExpectation.params != nil {
		mmAddRefreshSession.mock.t.Fatalf("FacadeMock.AddRefreshSession mock is already set by Expect")
	}

	if mmAddRefreshSession.defaultExpectation.paramPtrs == nil {
		mmAddRefreshSession.defaultExpectation.paramPtrs = &FacadeMockAddRefreshSessionParamPtrs{}
	}
	mmAddRefreshSession.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddRefreshSession.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddRefreshSession
}

// ExpectReqParam2 sets up expected param req for Facade.AddRefreshSession
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) ExpectReqParam2(req dto.RefreshSessionDto) *mFacadeMockAddRefreshSession {
	if mmAddRefreshSession.mock.funcAddRefreshSession != nil {
		mmAddRefreshSession.mock.t.Fatalf("FacadeMock.AddRefreshSession mock is already set by Set")
	}

	if mmAddRefreshSession.defaultExpectation == nil {
		mmAddRefreshSession.defaultExpectation = &FacadeMockAddRefreshSessionExpectation{}
	}

	if mmAddRefreshSession.defaultExpectation.params != nil {
		mmAddRefreshSession.mock.t.Fatalf("FacadeMock.AddRefreshSession mock is already set by Expect")
	}

	if mmAddRefreshSession.defaultExpectation.paramPtrs == nil {
		mmAddRefreshSession.defaultExpectation.paramPtrs = &FacadeMockAddRefreshSessionParamPtrs{}
	}
	mmAddRefreshSession.defaultExpectation.paramPtrs.req = &req
	mmAddRefreshSession.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmAddRefreshSession
}

// Inspect accepts an inspector function that has same arguments as the Facade.AddRefreshSession
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) Inspect(f func(ctx context.Context, req dto.RefreshSessionDto)) *mFacadeMockAddRefreshSession {
	if mmAddRefreshSession.mock.inspectFuncAddRefreshSession != nil {
		mmAddRefreshSession.mock.t.Fatalf("Inspect function is already set for FacadeMock.AddRefreshSession")
	}

	mmAddRefreshSession.mock.inspectFuncAddRefreshSession = f

	return mmAddRefreshSession
}

// Return sets up results that will be returned by Facade.AddRefreshSession
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) Return(err error) *FacadeMock {
	if mmAddRefreshSession.mock.funcAddRefreshSession != nil {
		mmAddRefreshSession.mock.t.Fatalf("FacadeMock.AddRefreshSession mock is already set by Set")
	}

	if mmAddRefreshSession.defaultExpectation == nil {
		mmAddRefreshSession.defaultExpectation = &FacadeMockAddRefreshSessionExpectation{mock: mmAddRefreshSession.mock}
	}
	mmAddRefreshSession.defaultExpectation.results = &FacadeMockAddRefreshSessionResults{err}
	mmAddRefreshSession.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddRefreshSession.mock
}

// Set uses given function f to mock the Facade.AddRefreshSession method
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) Set(f func(ctx context.Context, req dto.RefreshSessionDto) (err error)) *FacadeMock {
	if mmAddRefreshSession.defaultExpectation != nil {
		mmAddRefreshSession.mock.t.Fatalf("Default expectation is already set for the Facade.AddRefreshSession method")
	}

	if len(mmAddRefreshSession.expectations) > 0 {
		mmAddRefreshSession.mock.t.Fatalf("Some expectations are already set for the Facade.AddRefreshSession method")
	}

	mmAddRefreshSession.mock.funcAddRefreshSession = f
	mmAddRefreshSession.mock.funcAddRefreshSessionOrigin = minimock.CallerInfo(1)
	return mmAddRefreshSession.mock
}

// When sets expectation for the Facade.AddRefreshSession which will trigger the result defined by the following
// Then helper
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) When(ctx context.Context, req dto.RefreshSessionDto) *FacadeMockAddRefreshSessionExpectation {
	if mmAddRefreshSession.mock.funcAddRefreshSession != nil {
		mmAddRefreshSession.mock.t.Fatalf("FacadeMock.AddRefreshSession mock is already set by Set")
	}

	expectation := &FacadeMockAddRefreshSessionExpectation{
		mock:               mmAddRefreshSession.mock,
		params:             &FacadeMockAddRefreshSessionParams{ctx, req},
		expectationOrigins: FacadeMockAddRefreshSessionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddRefreshSession.expectations = append(mmAddRefreshSession.expectations, expectation)
	return expectation
}

// Then sets up Facade.AddRefreshSession return parameters for the expectation previously defined by the When method
func (e *FacadeMockAddRefreshSessionExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockAddRefreshSessionResults{err}
	return e.mock
}

// Times sets number of times Facade.AddRefreshSession should be invoked
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) Times(n uint64) *mFacadeMockAddRefreshSession {
	if n == 0 {
		mmAddRefreshSession.mock.t.Fatalf("Times of FacadeMock.AddRefreshSession mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddRefreshSession.expectedInvocations, n)
	mmAddRefreshSession.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddRefreshSession
}

func (mmAddRefreshSession *mFacadeMockAddRefreshSession) invocationsDone() bool {
	if len(mmAddRefreshSession.expectations) == 0 && mmAddRefreshSession.defaultExpectation == nil && mmAddRefreshSession.mock.funcAddRefreshSession == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddRefreshSession.mock.afterAddRefreshSessionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddRefreshSession.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddRefreshSession implements mm_repository.Facade
func (mmAddRefreshSession *FacadeMock) AddRefreshSession(ctx context.Context, req dto.RefreshSessionDto) (err error) {
	mm_atomic.AddUint64(&mmAddRefreshSession.beforeAddRefreshSessionCounter, 1)
	defer mm_atomic.AddUint64(&mmAddRefreshSession.afterAddRefreshSessionCounter, 1)

	mmAddRefreshSession.t.Helper()

	if mmAddRefreshSession.inspectFuncAddRefreshSession != nil {
		mmAddRefreshSession.inspectFuncAddRefreshSession(ctx, req)
	}

	mm_params := FacadeMockAddRefreshSessionParams{ctx, req}

	// Record call args
	mmAddRefreshSession.AddRefreshSessionMock.mutex.Lock()
	mmAddRefreshSession.AddRefreshSessionMock.callArgs = append(mmAddRefreshSession.AddRefreshSessionMock.callArgs, &mm_params)
	mmAddRefreshSession.AddRefreshSessionMock.mutex.Unlock()

	for _, e := range mmAddRefreshSession.AddRefreshSessionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddRefreshSession.AddRefreshSessionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddRefreshSession.AddRefreshSessionMock.defaultExpectation.Counter, 1)
		mm_want := mmAddRefreshSession.AddRefreshSessionMock.defaultExpectation.params
		mm_want_ptrs := mmAddRefreshSession.AddRefreshSessionMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockAddRefreshSessionParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddRefreshSession.t.Errorf("FacadeMock.AddRefreshSession got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRefreshSession.AddRefreshSessionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmAddRefreshSession.t.Errorf("FacadeMock.AddRefreshSession got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddRefreshSession.AddRefreshSessionMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddRefreshSession.t.Errorf("FacadeMock.AddRefreshSession got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddRefreshSession.AddRefreshSessionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddRefreshSession.AddRefreshSessionMock.defaultExpectation.results
		if mm_results == nil {
			mmAddRefreshSession.t.Fatal("No results are set for the FacadeMock.AddRefreshSession")
		}
		return (*mm_results).err
	}
	if mmAddRefreshSession.funcAddRefreshSession != nil {
		return mmAddRefreshSession.funcAddRefreshSession(ctx, req)
	}
	mmAddRefreshSession.t.Fatalf("Unexpected call to FacadeMock.AddRefreshSession. %v %v", ctx, req)
	return
}

// AddRefreshSessionAfterCounter returns a count of finished FacadeMock.AddRefreshSession invocations
func (mmAddRefreshSession *FacadeMock) AddRefreshSessionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRefreshSession.afterAddRefreshSessionCounter)
}

// AddRefreshSessionBeforeCounter returns a count of FacadeMock.AddRefreshSession invocations
func (mmAddRefreshSession *FacadeMock) AddRefreshSessionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddRefreshSession.beforeAddRefreshSessionCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.AddRefreshSession.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddRefreshSession *mFacadeMockAddRefreshSession) Calls() []*FacadeMockAddRefreshSessionParams {
	mmAddRefreshSession.mutex.RLock()

	argCopy := make([]*FacadeMockAddRefreshSessionParams, len(mmAddRefreshSession.callArgs))
	copy(argCopy, mmAddRefreshSession.callArgs)

	mmAddRefreshSession.mutex.RUnlock()

	return argCopy
}

// MinimockAddRefreshSessionDone returns true if the count of the AddRefreshSession invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockAddRefreshSessionDone() bool {
	if m.AddRefreshSessionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddRefreshSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddRefreshSessionMock.invocationsDone()
}

// MinimockAddRefreshSessionInspect logs each unmet expectation
func (m *FacadeMock) MinimockAddRefreshSessionInspect() {
	for _, e := range m.AddRefreshSessionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.AddRefreshSession at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddRefreshSessionCounter := mm_atomic.LoadUint64(&m.afterAddRefreshSessionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddRefreshSessionMock.defaultExpectation != nil && afterAddRefreshSessionCounter < 1 {
		if m.AddRefreshSessionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.AddRefreshSession at\n%s", m.AddRefreshSessionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.AddRefreshSession at\n%s with params: %#v", m.AddRefreshSessionMock.defaultExpectation.expectationOrigins.origin, *m.AddRefreshSessionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddRefreshSession != nil && afterAddRefreshSessionCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.AddRefreshSession at\n%s", m.funcAddRefreshSessionOrigin)
	}

	if !m.AddRefreshSessionMock.invocationsDone() && afterAddRefreshSessionCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.AddRefreshSession at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddRefreshSessionMock.expectedInvocations), m.AddRefreshSessionMock.expectedInvocationsOrigin, afterAddRefreshSessionCounter)
	}
}

type mFacadeMockAddUser struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockAddUserExpectation
	expectations       []*FacadeMockAddUserExpectation

	callArgs []*FacadeMockAddUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockAddUserExpectation specifies expectation struct of the Facade.AddUser
type FacadeMockAddUserExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockAddUserParams
	paramPtrs          *FacadeMockAddUserParamPtrs
	expectationOrigins FacadeMockAddUserExpectationOrigins
	results            *FacadeMockAddUserResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockAddUserParams contains parameters of the Facade.AddUser
type FacadeMockAddUserParams struct {
	ctx context.Context
	req dto.UserDto
}

// FacadeMockAddUserParamPtrs contains pointers to parameters of the Facade.AddUser
type FacadeMockAddUserParamPtrs struct {
	ctx *context.Context
	req *dto.UserDto
}

// FacadeMockAddUserResults contains results of the Facade.AddUser
type FacadeMockAddUserResults struct {
	err error
}

// FacadeMockAddUserOrigins contains origins of expectations of the Facade.AddUser
type FacadeMockAddUserExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddUser *mFacadeMockAddUser) Optional() *mFacadeMockAddUser {
	mmAddUser.optional = true
	return mmAddUser
}

// Expect sets up expected params for Facade.AddUser
func (mmAddUser *mFacadeMockAddUser) Expect(ctx context.Context, req dto.UserDto) *mFacadeMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("FacadeMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &FacadeMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.paramPtrs != nil {
		mmAddUser.mock.t.Fatalf("FacadeMock.AddUser mock is already set by ExpectParams functions")
	}

	mmAddUser.defaultExpectation.params = &FacadeMockAddUserParams{ctx, req}
	mmAddUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddUser.expectations {
		if minimock.Equal(e.params, mmAddUser.defaultExpectation.params) {
			mmAddUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddUser.defaultExpectation.params)
		}
	}

	return mmAddUser
}

// ExpectCtxParam1 sets up expected param ctx for Facade.AddUser
func (mmAddUser *mFacadeMockAddUser) ExpectCtxParam1(ctx context.Context) *mFacadeMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("FacadeMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &FacadeMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.params != nil {
		mmAddUser.mock.t.Fatalf("FacadeMock.AddUser mock is already set by Expect")
	}

	if mmAddUser.defaultExpectation.paramPtrs == nil {
		mmAddUser.defaultExpectation.paramPtrs = &FacadeMockAddUserParamPtrs{}
	}
	mmAddUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddUser
}

// ExpectReqParam2 sets up expected param req for Facade.AddUser
func (mmAddUser *mFacadeMockAddUser) ExpectReqParam2(req dto.UserDto) *mFacadeMockAddUser {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("FacadeMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &FacadeMockAddUserExpectation{}
	}

	if mmAddUser.defaultExpectation.params != nil {
		mmAddUser.mock.t.Fatalf("FacadeMock.AddUser mock is already set by Expect")
	}

	if mmAddUser.defaultExpectation.paramPtrs == nil {
		mmAddUser.defaultExpectation.paramPtrs = &FacadeMockAddUserParamPtrs{}
	}
	mmAddUser.defaultExpectation.paramPtrs.req = &req
	mmAddUser.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmAddUser
}

// Inspect accepts an inspector function that has same arguments as the Facade.AddUser
func (mmAddUser *mFacadeMockAddUser) Inspect(f func(ctx context.Context, req dto.UserDto)) *mFacadeMockAddUser {
	if mmAddUser.mock.inspectFuncAddUser != nil {
		mmAddUser.mock.t.Fatalf("Inspect function is already set for FacadeMock.AddUser")
	}

	mmAddUser.mock.inspectFuncAddUser = f

	return mmAddUser
}

// Return sets up results that will be returned by Facade.AddUser
func (mmAddUser *mFacadeMockAddUser) Return(err error) *FacadeMock {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("FacadeMock.AddUser mock is already set by Set")
	}

	if mmAddUser.defaultExpectation == nil {
		mmAddUser.defaultExpectation = &FacadeMockAddUserExpectation{mock: mmAddUser.mock}
	}
	mmAddUser.defaultExpectation.results = &FacadeMockAddUserResults{err}
	mmAddUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddUser.mock
}

// Set uses given function f to mock the Facade.AddUser method
func (mmAddUser *mFacadeMockAddUser) Set(f func(ctx context.Context, req dto.UserDto) (err error)) *FacadeMock {
	if mmAddUser.defaultExpectation != nil {
		mmAddUser.mock.t.Fatalf("Default expectation is already set for the Facade.AddUser method")
	}

	if len(mmAddUser.expectations) > 0 {
		mmAddUser.mock.t.Fatalf("Some expectations are already set for the Facade.AddUser method")
	}

	mmAddUser.mock.funcAddUser = f
	mmAddUser.mock.funcAddUserOrigin = minimock.CallerInfo(1)
	return mmAddUser.mock
}

// When sets expectation for the Facade.AddUser which will trigger the result defined by the following
// Then helper
func (mmAddUser *mFacadeMockAddUser) When(ctx context.Context, req dto.UserDto) *FacadeMockAddUserExpectation {
	if mmAddUser.mock.funcAddUser != nil {
		mmAddUser.mock.t.Fatalf("FacadeMock.AddUser mock is already set by Set")
	}

	expectation := &FacadeMockAddUserExpectation{
		mock:               mmAddUser.mock,
		params:             &FacadeMockAddUserParams{ctx, req},
		expectationOrigins: FacadeMockAddUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddUser.expectations = append(mmAddUser.expectations, expectation)
	return expectation
}

// Then sets up Facade.AddUser return parameters for the expectation previously defined by the When method
func (e *FacadeMockAddUserExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockAddUserResults{err}
	return e.mock
}

// Times sets number of times Facade.AddUser should be invoked
func (mmAddUser *mFacadeMockAddUser) Times(n uint64) *mFacadeMockAddUser {
	if n == 0 {
		mmAddUser.mock.t.Fatalf("Times of FacadeMock.AddUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddUser.expectedInvocations, n)
	mmAddUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddUser
}

func (mmAddUser *mFacadeMockAddUser) invocationsDone() bool {
	if len(mmAddUser.expectations) == 0 && mmAddUser.defaultExpectation == nil && mmAddUser.mock.funcAddUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddUser.mock.afterAddUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddUser implements mm_repository.Facade
func (mmAddUser *FacadeMock) AddUser(ctx context.Context, req dto.UserDto) (err error) {
	mm_atomic.AddUint64(&mmAddUser.beforeAddUserCounter, 1)
	defer mm_atomic.AddUint64(&mmAddUser.afterAddUserCounter, 1)

	mmAddUser.t.Helper()

	if mmAddUser.inspectFuncAddUser != nil {
		mmAddUser.inspectFuncAddUser(ctx, req)
	}

	mm_params := FacadeMockAddUserParams{ctx, req}

	// Record call args
	mmAddUser.AddUserMock.mutex.Lock()
	mmAddUser.AddUserMock.callArgs = append(mmAddUser.AddUserMock.callArgs, &mm_params)
	mmAddUser.AddUserMock.mutex.Unlock()

	for _, e := range mmAddUser.AddUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddUser.AddUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddUser.AddUserMock.defaultExpectation.Counter, 1)
		mm_want := mmAddUser.AddUserMock.defaultExpectation.params
		mm_want_ptrs := mmAddUser.AddUserMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockAddUserParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddUser.t.Errorf("FacadeMock.AddUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUser.AddUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmAddUser.t.Errorf("FacadeMock.AddUser got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddUser.AddUserMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddUser.t.Errorf("FacadeMock.AddUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddUser.AddUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddUser.AddUserMock.defaultExpectation.results
		if mm_results == nil {
			mmAddUser.t.Fatal("No results are set for the FacadeMock.AddUser")
		}
		return (*mm_results).err
	}
	if mmAddUser.funcAddUser != nil {
		return mmAddUser.funcAddUser(ctx, req)
	}
	mmAddUser.t.Fatalf("Unexpected call to FacadeMock.AddUser. %v %v", ctx, req)
	return
}

// AddUserAfterCounter returns a count of finished FacadeMock.AddUser invocations
func (mmAddUser *FacadeMock) AddUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.afterAddUserCounter)
}

// AddUserBeforeCounter returns a count of FacadeMock.AddUser invocations
func (mmAddUser *FacadeMock) AddUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddUser.beforeAddUserCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.AddUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddUser *mFacadeMockAddUser) Calls() []*FacadeMockAddUserParams {
	mmAddUser.mutex.RLock()

	argCopy := make([]*FacadeMockAddUserParams, len(mmAddUser.callArgs))
	copy(argCopy, mmAddUser.callArgs)

	mmAddUser.mutex.RUnlock()

	return argCopy
}

// MinimockAddUserDone returns true if the count of the AddUser invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockAddUserDone() bool {
	if m.AddUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddUserMock.invocationsDone()
}

// MinimockAddUserInspect logs each unmet expectation
func (m *FacadeMock) MinimockAddUserInspect() {
	for _, e := range m.AddUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.AddUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddUserCounter := mm_atomic.LoadUint64(&m.afterAddUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddUserMock.defaultExpectation != nil && afterAddUserCounter < 1 {
		if m.AddUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.AddUser at\n%s", m.AddUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.AddUser at\n%s with params: %#v", m.AddUserMock.defaultExpectation.expectationOrigins.origin, *m.AddUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddUser != nil && afterAddUserCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.AddUser at\n%s", m.funcAddUserOrigin)
	}

	if !m.AddUserMock.invocationsDone() && afterAddUserCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.AddUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddUserMock.expectedInvocations), m.AddUserMock.expectedInvocationsOrigin, afterAddUserCounter)
	}
}

type mFacadeMockDeleteAsset struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockDeleteAssetExpectation
	expectations       []*FacadeMockDeleteAssetExpectation

	callArgs []*FacadeMockDeleteAssetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockDeleteAssetExpectation specifies expectation struct of the Facade.DeleteAsset
type FacadeMockDeleteAssetExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockDeleteAssetParams
	paramPtrs          *FacadeMockDeleteAssetParamPtrs
	expectationOrigins FacadeMockDeleteAssetExpectationOrigins
	results            *FacadeMockDeleteAssetResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockDeleteAssetParams contains parameters of the Facade.DeleteAsset
type FacadeMockDeleteAssetParams struct {
	ctx context.Context
	req dto.DeleteAssetDto
}

// FacadeMockDeleteAssetParamPtrs contains pointers to parameters of the Facade.DeleteAsset
type FacadeMockDeleteAssetParamPtrs struct {
	ctx *context.Context
	req *dto.DeleteAssetDto
}

// FacadeMockDeleteAssetResults contains results of the Facade.DeleteAsset
type FacadeMockDeleteAssetResults struct {
	err error
}

// FacadeMockDeleteAssetOrigins contains origins of expectations of the Facade.DeleteAsset
type FacadeMockDeleteAssetExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAsset *mFacadeMockDeleteAsset) Optional() *mFacadeMockDeleteAsset {
	mmDeleteAsset.optional = true
	return mmDeleteAsset
}

// Expect sets up expected params for Facade.DeleteAsset
func (mmDeleteAsset *mFacadeMockDeleteAsset) Expect(ctx context.Context, req dto.DeleteAssetDto) *mFacadeMockDeleteAsset {
	if mmDeleteAsset.mock.funcDeleteAsset != nil {
		mmDeleteAsset.mock.t.Fatalf("FacadeMock.DeleteAsset mock is already set by Set")
	}

	if mmDeleteAsset.defaultExpectation == nil {
		mmDeleteAsset.defaultExpectation = &FacadeMockDeleteAssetExpectation{}
	}

	if mmDeleteAsset.defaultExpectation.paramPtrs != nil {
		mmDeleteAsset.mock.t.Fatalf("FacadeMock.DeleteAsset mock is already set by ExpectParams functions")
	}

	mmDeleteAsset.defaultExpectation.params = &FacadeMockDeleteAssetParams{ctx, req}
	mmDeleteAsset.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteAsset.expectations {
		if minimock.Equal(e.params, mmDeleteAsset.defaultExpectation.params) {
			mmDeleteAsset.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAsset.defaultExpectation.params)
		}
	}

	return mmDeleteAsset
}

// ExpectCtxParam1 sets up expected param ctx for Facade.DeleteAsset
func (mmDeleteAsset *mFacadeMockDeleteAsset) ExpectCtxParam1(ctx context.Context) *mFacadeMockDeleteAsset {
	if mmDeleteAsset.mock.funcDeleteAsset != nil {
		mmDeleteAsset.mock.t.Fatalf("FacadeMock.DeleteAsset mock is already set by Set")
	}

	if mmDeleteAsset.defaultExpectation == nil {
		mmDeleteAsset.defaultExpectation = &FacadeMockDeleteAssetExpectation{}
	}

	if mmDeleteAsset.defaultExpectation.params != nil {
		mmDeleteAsset.mock.t.Fatalf("FacadeMock.DeleteAsset mock is already set by Expect")
	}

	if mmDeleteAsset.defaultExpectation.paramPtrs == nil {
		mmDeleteAsset.defaultExpectation.paramPtrs = &FacadeMockDeleteAssetParamPtrs{}
	}
	mmDeleteAsset.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteAsset.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteAsset
}

// ExpectReqParam2 sets up expected param req for Facade.DeleteAsset
func (mmDeleteAsset *mFacadeMockDeleteAsset) ExpectReqParam2(req dto.DeleteAssetDto) *mFacadeMockDeleteAsset {
	if mmDeleteAsset.mock.funcDeleteAsset != nil {
		mmDeleteAsset.mock.t.Fatalf("FacadeMock.DeleteAsset mock is already set by Set")
	}

	if mmDeleteAsset.defaultExpectation == nil {
		mmDeleteAsset.defaultExpectation = &FacadeMockDeleteAssetExpectation{}
	}

	if mmDeleteAsset.defaultExpectation.params != nil {
		mmDeleteAsset.mock.t.Fatalf("FacadeMock.DeleteAsset mock is already set by Expect")
	}

	if mmDeleteAsset.defaultExpectation.paramPtrs == nil {
		mmDeleteAsset.defaultExpectation.paramPtrs = &FacadeMockDeleteAssetParamPtrs{}
	}
	mmDeleteAsset.defaultExpectation.paramPtrs.req = &req
	mmDeleteAsset.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmDeleteAsset
}

// Inspect accepts an inspector function that has same arguments as the Facade.DeleteAsset
func (mmDeleteAsset *mFacadeMockDeleteAsset) Inspect(f func(ctx context.Context, req dto.DeleteAssetDto)) *mFacadeMockDeleteAsset {
	if mmDeleteAsset.mock.inspectFuncDeleteAsset != nil {
		mmDeleteAsset.mock.t.Fatalf("Inspect function is already set for FacadeMock.DeleteAsset")
	}

	mmDeleteAsset.mock.inspectFuncDeleteAsset = f

	return mmDeleteAsset
}

// Return sets up results that will be returned by Facade.DeleteAsset
func (mmDeleteAsset *mFacadeMockDeleteAsset) Return(err error) *FacadeMock {
	if mmDeleteAsset.mock.funcDeleteAsset != nil {
		mmDeleteAsset.mock.t.Fatalf("FacadeMock.DeleteAsset mock is already set by Set")
	}

	if mmDeleteAsset.defaultExpectation == nil {
		mmDeleteAsset.defaultExpectation = &FacadeMockDeleteAssetExpectation{mock: mmDeleteAsset.mock}
	}
	mmDeleteAsset.defaultExpectation.results = &FacadeMockDeleteAssetResults{err}
	mmDeleteAsset.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteAsset.mock
}

// Set uses given function f to mock the Facade.DeleteAsset method
func (mmDeleteAsset *mFacadeMockDeleteAsset) Set(f func(ctx context.Context, req dto.DeleteAssetDto) (err error)) *FacadeMock {
	if mmDeleteAsset.defaultExpectation != nil {
		mmDeleteAsset.mock.t.Fatalf("Default expectation is already set for the Facade.DeleteAsset method")
	}

	if len(mmDeleteAsset.expectations) > 0 {
		mmDeleteAsset.mock.t.Fatalf("Some expectations are already set for the Facade.DeleteAsset method")
	}

	mmDeleteAsset.mock.funcDeleteAsset = f
	mmDeleteAsset.mock.funcDeleteAssetOrigin = minimock.CallerInfo(1)
	return mmDeleteAsset.mock
}

// When sets expectation for the Facade.DeleteAsset which will trigger the result defined by the following
// Then helper
func (mmDeleteAsset *mFacadeMockDeleteAsset) When(ctx context.Context, req dto.DeleteAssetDto) *FacadeMockDeleteAssetExpectation {
	if mmDeleteAsset.mock.funcDeleteAsset != nil {
		mmDeleteAsset.mock.t.Fatalf("FacadeMock.DeleteAsset mock is already set by Set")
	}

	expectation := &FacadeMockDeleteAssetExpectation{
		mock:               mmDeleteAsset.mock,
		params:             &FacadeMockDeleteAssetParams{ctx, req},
		expectationOrigins: FacadeMockDeleteAssetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteAsset.expectations = append(mmDeleteAsset.expectations, expectation)
	return expectation
}

// Then sets up Facade.DeleteAsset return parameters for the expectation previously defined by the When method
func (e *FacadeMockDeleteAssetExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockDeleteAssetResults{err}
	return e.mock
}

// Times sets number of times Facade.DeleteAsset should be invoked
func (mmDeleteAsset *mFacadeMockDeleteAsset) Times(n uint64) *mFacadeMockDeleteAsset {
	if n == 0 {
		mmDeleteAsset.mock.t.Fatalf("Times of FacadeMock.DeleteAsset mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAsset.expectedInvocations, n)
	mmDeleteAsset.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteAsset
}

func (mmDeleteAsset *mFacadeMockDeleteAsset) invocationsDone() bool {
	if len(mmDeleteAsset.expectations) == 0 && mmDeleteAsset.defaultExpectation == nil && mmDeleteAsset.mock.funcDeleteAsset == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAsset.mock.afterDeleteAssetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAsset.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAsset implements mm_repository.Facade
func (mmDeleteAsset *FacadeMock) DeleteAsset(ctx context.Context, req dto.DeleteAssetDto) (err error) {
	mm_atomic.AddUint64(&mmDeleteAsset.beforeDeleteAssetCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAsset.afterDeleteAssetCounter, 1)

	mmDeleteAsset.t.Helper()

	if mmDeleteAsset.inspectFuncDeleteAsset != nil {
		mmDeleteAsset.inspectFuncDeleteAsset(ctx, req)
	}

	mm_params := FacadeMockDeleteAssetParams{ctx, req}

	// Record call args
	mmDeleteAsset.DeleteAssetMock.mutex.Lock()
	mmDeleteAsset.DeleteAssetMock.callArgs = append(mmDeleteAsset.DeleteAssetMock.callArgs, &mm_params)
	mmDeleteAsset.DeleteAssetMock.mutex.Unlock()

	for _, e := range mmDeleteAsset.DeleteAssetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteAsset.DeleteAssetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAsset.DeleteAssetMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAsset.DeleteAssetMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAsset.DeleteAssetMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockDeleteAssetParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAsset.t.Errorf("FacadeMock.DeleteAsset got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAsset.DeleteAssetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmDeleteAsset.t.Errorf("FacadeMock.DeleteAsset got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteAsset.DeleteAssetMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAsset.t.Errorf("FacadeMock.DeleteAsset got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteAsset.DeleteAssetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAsset.DeleteAssetMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAsset.t.Fatal("No results are set for the FacadeMock.DeleteAsset")
		}
		return (*mm_results).err
	}
	if mmDeleteAsset.funcDeleteAsset != nil {
		return mmDeleteAsset.funcDeleteAsset(ctx, req)
	}
	mmDeleteAsset.t.Fatalf("Unexpected call to FacadeMock.DeleteAsset. %v %v", ctx, req)
	return
}

// DeleteAssetAfterCounter returns a count of finished FacadeMock.DeleteAsset invocations
func (mmDeleteAsset *FacadeMock) DeleteAssetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAsset.afterDeleteAssetCounter)
}

// DeleteAssetBeforeCounter returns a count of FacadeMock.DeleteAsset invocations
func (mmDeleteAsset *FacadeMock) DeleteAssetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAsset.beforeDeleteAssetCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.DeleteAsset.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAsset *mFacadeMockDeleteAsset) Calls() []*FacadeMockDeleteAssetParams {
	mmDeleteAsset.mutex.RLock()

	argCopy := make([]*FacadeMockDeleteAssetParams, len(mmDeleteAsset.callArgs))
	copy(argCopy, mmDeleteAsset.callArgs)

	mmDeleteAsset.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAssetDone returns true if the count of the DeleteAsset invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockDeleteAssetDone() bool {
	if m.DeleteAssetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAssetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAssetMock.invocationsDone()
}

// MinimockDeleteAssetInspect logs each unmet expectation
func (m *FacadeMock) MinimockDeleteAssetInspect() {
	for _, e := range m.DeleteAssetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.DeleteAsset at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteAssetCounter := mm_atomic.LoadUint64(&m.afterDeleteAssetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAssetMock.defaultExpectation != nil && afterDeleteAssetCounter < 1 {
		if m.DeleteAssetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.DeleteAsset at\n%s", m.DeleteAssetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.DeleteAsset at\n%s with params: %#v", m.DeleteAssetMock.defaultExpectation.expectationOrigins.origin, *m.DeleteAssetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAsset != nil && afterDeleteAssetCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.DeleteAsset at\n%s", m.funcDeleteAssetOrigin)
	}

	if !m.DeleteAssetMock.invocationsDone() && afterDeleteAssetCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.DeleteAsset at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAssetMock.expectedInvocations), m.DeleteAssetMock.expectedInvocationsOrigin, afterDeleteAssetCounter)
	}
}

type mFacadeMockGetAssetInfo struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetAssetInfoExpectation
	expectations       []*FacadeMockGetAssetInfoExpectation

	callArgs []*FacadeMockGetAssetInfoParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetAssetInfoExpectation specifies expectation struct of the Facade.GetAssetInfo
type FacadeMockGetAssetInfoExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetAssetInfoParams
	paramPtrs          *FacadeMockGetAssetInfoParamPtrs
	expectationOrigins FacadeMockGetAssetInfoExpectationOrigins
	results            *FacadeMockGetAssetInfoResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetAssetInfoParams contains parameters of the Facade.GetAssetInfo
type FacadeMockGetAssetInfoParams struct {
	ctx       context.Context
	assetName string
}

// FacadeMockGetAssetInfoParamPtrs contains pointers to parameters of the Facade.GetAssetInfo
type FacadeMockGetAssetInfoParamPtrs struct {
	ctx       *context.Context
	assetName *string
}

// FacadeMockGetAssetInfoResults contains results of the Facade.GetAssetInfo
type FacadeMockGetAssetInfoResults struct {
	ap1 *dto.AssetDto
	err error
}

// FacadeMockGetAssetInfoOrigins contains origins of expectations of the Facade.GetAssetInfo
type FacadeMockGetAssetInfoExpectationOrigins struct {
	origin          string
	originCtx       string
	originAssetName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) Optional() *mFacadeMockGetAssetInfo {
	mmGetAssetInfo.optional = true
	return mmGetAssetInfo
}

// Expect sets up expected params for Facade.GetAssetInfo
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) Expect(ctx context.Context, assetName string) *mFacadeMockGetAssetInfo {
	if mmGetAssetInfo.mock.funcGetAssetInfo != nil {
		mmGetAssetInfo.mock.t.Fatalf("FacadeMock.GetAssetInfo mock is already set by Set")
	}

	if mmGetAssetInfo.defaultExpectation == nil {
		mmGetAssetInfo.defaultExpectation = &FacadeMockGetAssetInfoExpectation{}
	}

	if mmGetAssetInfo.defaultExpectation.paramPtrs != nil {
		mmGetAssetInfo.mock.t.Fatalf("FacadeMock.GetAssetInfo mock is already set by ExpectParams functions")
	}

	mmGetAssetInfo.defaultExpectation.params = &FacadeMockGetAssetInfoParams{ctx, assetName}
	mmGetAssetInfo.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAssetInfo.expectations {
		if minimock.Equal(e.params, mmGetAssetInfo.defaultExpectation.params) {
			mmGetAssetInfo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAssetInfo.defaultExpectation.params)
		}
	}

	return mmGetAssetInfo
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetAssetInfo
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetAssetInfo {
	if mmGetAssetInfo.mock.funcGetAssetInfo != nil {
		mmGetAssetInfo.mock.t.Fatalf("FacadeMock.GetAssetInfo mock is already set by Set")
	}

	if mmGetAssetInfo.defaultExpectation == nil {
		mmGetAssetInfo.defaultExpectation = &FacadeMockGetAssetInfoExpectation{}
	}

	if mmGetAssetInfo.defaultExpectation.params != nil {
		mmGetAssetInfo.mock.t.Fatalf("FacadeMock.GetAssetInfo mock is already set by Expect")
	}

	if mmGetAssetInfo.defaultExpectation.paramPtrs == nil {
		mmGetAssetInfo.defaultExpectation.paramPtrs = &FacadeMockGetAssetInfoParamPtrs{}
	}
	mmGetAssetInfo.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAssetInfo.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAssetInfo
}

// ExpectAssetNameParam2 sets up expected param assetName for Facade.GetAssetInfo
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) ExpectAssetNameParam2(assetName string) *mFacadeMockGetAssetInfo {
	if mmGetAssetInfo.mock.funcGetAssetInfo != nil {
		mmGetAssetInfo.mock.t.Fatalf("FacadeMock.GetAssetInfo mock is already set by Set")
	}

	if mmGetAssetInfo.defaultExpectation == nil {
		mmGetAssetInfo.defaultExpectation = &FacadeMockGetAssetInfoExpectation{}
	}

	if mmGetAssetInfo.defaultExpectation.params != nil {
		mmGetAssetInfo.mock.t.Fatalf("FacadeMock.GetAssetInfo mock is already set by Expect")
	}

	if mmGetAssetInfo.defaultExpectation.paramPtrs == nil {
		mmGetAssetInfo.defaultExpectation.paramPtrs = &FacadeMockGetAssetInfoParamPtrs{}
	}
	mmGetAssetInfo.defaultExpectation.paramPtrs.assetName = &assetName
	mmGetAssetInfo.defaultExpectation.expectationOrigins.originAssetName = minimock.CallerInfo(1)

	return mmGetAssetInfo
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetAssetInfo
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) Inspect(f func(ctx context.Context, assetName string)) *mFacadeMockGetAssetInfo {
	if mmGetAssetInfo.mock.inspectFuncGetAssetInfo != nil {
		mmGetAssetInfo.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetAssetInfo")
	}

	mmGetAssetInfo.mock.inspectFuncGetAssetInfo = f

	return mmGetAssetInfo
}

// Return sets up results that will be returned by Facade.GetAssetInfo
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) Return(ap1 *dto.AssetDto, err error) *FacadeMock {
	if mmGetAssetInfo.mock.funcGetAssetInfo != nil {
		mmGetAssetInfo.mock.t.Fatalf("FacadeMock.GetAssetInfo mock is already set by Set")
	}

	if mmGetAssetInfo.defaultExpectation == nil {
		mmGetAssetInfo.defaultExpectation = &FacadeMockGetAssetInfoExpectation{mock: mmGetAssetInfo.mock}
	}
	mmGetAssetInfo.defaultExpectation.results = &FacadeMockGetAssetInfoResults{ap1, err}
	mmGetAssetInfo.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAssetInfo.mock
}

// Set uses given function f to mock the Facade.GetAssetInfo method
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) Set(f func(ctx context.Context, assetName string) (ap1 *dto.AssetDto, err error)) *FacadeMock {
	if mmGetAssetInfo.defaultExpectation != nil {
		mmGetAssetInfo.mock.t.Fatalf("Default expectation is already set for the Facade.GetAssetInfo method")
	}

	if len(mmGetAssetInfo.expectations) > 0 {
		mmGetAssetInfo.mock.t.Fatalf("Some expectations are already set for the Facade.GetAssetInfo method")
	}

	mmGetAssetInfo.mock.funcGetAssetInfo = f
	mmGetAssetInfo.mock.funcGetAssetInfoOrigin = minimock.CallerInfo(1)
	return mmGetAssetInfo.mock
}

// When sets expectation for the Facade.GetAssetInfo which will trigger the result defined by the following
// Then helper
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) When(ctx context.Context, assetName string) *FacadeMockGetAssetInfoExpectation {
	if mmGetAssetInfo.mock.funcGetAssetInfo != nil {
		mmGetAssetInfo.mock.t.Fatalf("FacadeMock.GetAssetInfo mock is already set by Set")
	}

	expectation := &FacadeMockGetAssetInfoExpectation{
		mock:               mmGetAssetInfo.mock,
		params:             &FacadeMockGetAssetInfoParams{ctx, assetName},
		expectationOrigins: FacadeMockGetAssetInfoExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAssetInfo.expectations = append(mmGetAssetInfo.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetAssetInfo return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetAssetInfoExpectation) Then(ap1 *dto.AssetDto, err error) *FacadeMock {
	e.results = &FacadeMockGetAssetInfoResults{ap1, err}
	return e.mock
}

// Times sets number of times Facade.GetAssetInfo should be invoked
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) Times(n uint64) *mFacadeMockGetAssetInfo {
	if n == 0 {
		mmGetAssetInfo.mock.t.Fatalf("Times of FacadeMock.GetAssetInfo mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAssetInfo.expectedInvocations, n)
	mmGetAssetInfo.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAssetInfo
}

func (mmGetAssetInfo *mFacadeMockGetAssetInfo) invocationsDone() bool {
	if len(mmGetAssetInfo.expectations) == 0 && mmGetAssetInfo.defaultExpectation == nil && mmGetAssetInfo.mock.funcGetAssetInfo == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAssetInfo.mock.afterGetAssetInfoCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAssetInfo.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAssetInfo implements mm_repository.Facade
func (mmGetAssetInfo *FacadeMock) GetAssetInfo(ctx context.Context, assetName string) (ap1 *dto.AssetDto, err error) {
	mm_atomic.AddUint64(&mmGetAssetInfo.beforeGetAssetInfoCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAssetInfo.afterGetAssetInfoCounter, 1)

	mmGetAssetInfo.t.Helper()

	if mmGetAssetInfo.inspectFuncGetAssetInfo != nil {
		mmGetAssetInfo.inspectFuncGetAssetInfo(ctx, assetName)
	}

	mm_params := FacadeMockGetAssetInfoParams{ctx, assetName}

	// Record call args
	mmGetAssetInfo.GetAssetInfoMock.mutex.Lock()
	mmGetAssetInfo.GetAssetInfoMock.callArgs = append(mmGetAssetInfo.GetAssetInfoMock.callArgs, &mm_params)
	mmGetAssetInfo.GetAssetInfoMock.mutex.Unlock()

	for _, e := range mmGetAssetInfo.GetAssetInfoMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetAssetInfo.GetAssetInfoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAssetInfo.GetAssetInfoMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAssetInfo.GetAssetInfoMock.defaultExpectation.params
		mm_want_ptrs := mmGetAssetInfo.GetAssetInfoMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetAssetInfoParams{ctx, assetName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAssetInfo.t.Errorf("FacadeMock.GetAssetInfo got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAssetInfo.GetAssetInfoMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.assetName != nil && !minimock.Equal(*mm_want_ptrs.assetName, mm_got.assetName) {
				mmGetAssetInfo.t.Errorf("FacadeMock.GetAssetInfo got unexpected parameter assetName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAssetInfo.GetAssetInfoMock.defaultExpectation.expectationOrigins.originAssetName, *mm_want_ptrs.assetName, mm_got.assetName, minimock.Diff(*mm_want_ptrs.assetName, mm_got.assetName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAssetInfo.t.Errorf("FacadeMock.GetAssetInfo got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAssetInfo.GetAssetInfoMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAssetInfo.GetAssetInfoMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAssetInfo.t.Fatal("No results are set for the FacadeMock.GetAssetInfo")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetAssetInfo.funcGetAssetInfo != nil {
		return mmGetAssetInfo.funcGetAssetInfo(ctx, assetName)
	}
	mmGetAssetInfo.t.Fatalf("Unexpected call to FacadeMock.GetAssetInfo. %v %v", ctx, assetName)
	return
}

// GetAssetInfoAfterCounter returns a count of finished FacadeMock.GetAssetInfo invocations
func (mmGetAssetInfo *FacadeMock) GetAssetInfoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAssetInfo.afterGetAssetInfoCounter)
}

// GetAssetInfoBeforeCounter returns a count of FacadeMock.GetAssetInfo invocations
func (mmGetAssetInfo *FacadeMock) GetAssetInfoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAssetInfo.beforeGetAssetInfoCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetAssetInfo.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAssetInfo *mFacadeMockGetAssetInfo) Calls() []*FacadeMockGetAssetInfoParams {
	mmGetAssetInfo.mutex.RLock()

	argCopy := make([]*FacadeMockGetAssetInfoParams, len(mmGetAssetInfo.callArgs))
	copy(argCopy, mmGetAssetInfo.callArgs)

	mmGetAssetInfo.mutex.RUnlock()

	return argCopy
}

// MinimockGetAssetInfoDone returns true if the count of the GetAssetInfo invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetAssetInfoDone() bool {
	if m.GetAssetInfoMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAssetInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAssetInfoMock.invocationsDone()
}

// MinimockGetAssetInfoInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetAssetInfoInspect() {
	for _, e := range m.GetAssetInfoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetAssetInfo at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAssetInfoCounter := mm_atomic.LoadUint64(&m.afterGetAssetInfoCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAssetInfoMock.defaultExpectation != nil && afterGetAssetInfoCounter < 1 {
		if m.GetAssetInfoMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetAssetInfo at\n%s", m.GetAssetInfoMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetAssetInfo at\n%s with params: %#v", m.GetAssetInfoMock.defaultExpectation.expectationOrigins.origin, *m.GetAssetInfoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAssetInfo != nil && afterGetAssetInfoCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetAssetInfo at\n%s", m.funcGetAssetInfoOrigin)
	}

	if !m.GetAssetInfoMock.invocationsDone() && afterGetAssetInfoCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetAssetInfo at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAssetInfoMock.expectedInvocations), m.GetAssetInfoMock.expectedInvocationsOrigin, afterGetAssetInfoCounter)
	}
}

type mFacadeMockGetUserByUsername struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockGetUserByUsernameExpectation
	expectations       []*FacadeMockGetUserByUsernameExpectation

	callArgs []*FacadeMockGetUserByUsernameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockGetUserByUsernameExpectation specifies expectation struct of the Facade.GetUserByUsername
type FacadeMockGetUserByUsernameExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockGetUserByUsernameParams
	paramPtrs          *FacadeMockGetUserByUsernameParamPtrs
	expectationOrigins FacadeMockGetUserByUsernameExpectationOrigins
	results            *FacadeMockGetUserByUsernameResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockGetUserByUsernameParams contains parameters of the Facade.GetUserByUsername
type FacadeMockGetUserByUsernameParams struct {
	ctx      context.Context
	username string
}

// FacadeMockGetUserByUsernameParamPtrs contains pointers to parameters of the Facade.GetUserByUsername
type FacadeMockGetUserByUsernameParamPtrs struct {
	ctx      *context.Context
	username *string
}

// FacadeMockGetUserByUsernameResults contains results of the Facade.GetUserByUsername
type FacadeMockGetUserByUsernameResults struct {
	up1 *dto.UserDto
	err error
}

// FacadeMockGetUserByUsernameOrigins contains origins of expectations of the Facade.GetUserByUsername
type FacadeMockGetUserByUsernameExpectationOrigins struct {
	origin         string
	originCtx      string
	originUsername string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) Optional() *mFacadeMockGetUserByUsername {
	mmGetUserByUsername.optional = true
	return mmGetUserByUsername
}

// Expect sets up expected params for Facade.GetUserByUsername
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) Expect(ctx context.Context, username string) *mFacadeMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("FacadeMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &FacadeMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs != nil {
		mmGetUserByUsername.mock.t.Fatalf("FacadeMock.GetUserByUsername mock is already set by ExpectParams functions")
	}

	mmGetUserByUsername.defaultExpectation.params = &FacadeMockGetUserByUsernameParams{ctx, username}
	mmGetUserByUsername.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByUsername.expectations {
		if minimock.Equal(e.params, mmGetUserByUsername.defaultExpectation.params) {
			mmGetUserByUsername.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByUsername.defaultExpectation.params)
		}
	}

	return mmGetUserByUsername
}

// ExpectCtxParam1 sets up expected param ctx for Facade.GetUserByUsername
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) ExpectCtxParam1(ctx context.Context) *mFacadeMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("FacadeMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &FacadeMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.params != nil {
		mmGetUserByUsername.mock.t.Fatalf("FacadeMock.GetUserByUsername mock is already set by Expect")
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs == nil {
		mmGetUserByUsername.defaultExpectation.paramPtrs = &FacadeMockGetUserByUsernameParamPtrs{}
	}
	mmGetUserByUsername.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByUsername.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByUsername
}

// ExpectUsernameParam2 sets up expected param username for Facade.GetUserByUsername
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) ExpectUsernameParam2(username string) *mFacadeMockGetUserByUsername {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("FacadeMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &FacadeMockGetUserByUsernameExpectation{}
	}

	if mmGetUserByUsername.defaultExpectation.params != nil {
		mmGetUserByUsername.mock.t.Fatalf("FacadeMock.GetUserByUsername mock is already set by Expect")
	}

	if mmGetUserByUsername.defaultExpectation.paramPtrs == nil {
		mmGetUserByUsername.defaultExpectation.paramPtrs = &FacadeMockGetUserByUsernameParamPtrs{}
	}
	mmGetUserByUsername.defaultExpectation.paramPtrs.username = &username
	mmGetUserByUsername.defaultExpectation.expectationOrigins.originUsername = minimock.CallerInfo(1)

	return mmGetUserByUsername
}

// Inspect accepts an inspector function that has same arguments as the Facade.GetUserByUsername
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) Inspect(f func(ctx context.Context, username string)) *mFacadeMockGetUserByUsername {
	if mmGetUserByUsername.mock.inspectFuncGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("Inspect function is already set for FacadeMock.GetUserByUsername")
	}

	mmGetUserByUsername.mock.inspectFuncGetUserByUsername = f

	return mmGetUserByUsername
}

// Return sets up results that will be returned by Facade.GetUserByUsername
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) Return(up1 *dto.UserDto, err error) *FacadeMock {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("FacadeMock.GetUserByUsername mock is already set by Set")
	}

	if mmGetUserByUsername.defaultExpectation == nil {
		mmGetUserByUsername.defaultExpectation = &FacadeMockGetUserByUsernameExpectation{mock: mmGetUserByUsername.mock}
	}
	mmGetUserByUsername.defaultExpectation.results = &FacadeMockGetUserByUsernameResults{up1, err}
	mmGetUserByUsername.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByUsername.mock
}

// Set uses given function f to mock the Facade.GetUserByUsername method
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) Set(f func(ctx context.Context, username string) (up1 *dto.UserDto, err error)) *FacadeMock {
	if mmGetUserByUsername.defaultExpectation != nil {
		mmGetUserByUsername.mock.t.Fatalf("Default expectation is already set for the Facade.GetUserByUsername method")
	}

	if len(mmGetUserByUsername.expectations) > 0 {
		mmGetUserByUsername.mock.t.Fatalf("Some expectations are already set for the Facade.GetUserByUsername method")
	}

	mmGetUserByUsername.mock.funcGetUserByUsername = f
	mmGetUserByUsername.mock.funcGetUserByUsernameOrigin = minimock.CallerInfo(1)
	return mmGetUserByUsername.mock
}

// When sets expectation for the Facade.GetUserByUsername which will trigger the result defined by the following
// Then helper
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) When(ctx context.Context, username string) *FacadeMockGetUserByUsernameExpectation {
	if mmGetUserByUsername.mock.funcGetUserByUsername != nil {
		mmGetUserByUsername.mock.t.Fatalf("FacadeMock.GetUserByUsername mock is already set by Set")
	}

	expectation := &FacadeMockGetUserByUsernameExpectation{
		mock:               mmGetUserByUsername.mock,
		params:             &FacadeMockGetUserByUsernameParams{ctx, username},
		expectationOrigins: FacadeMockGetUserByUsernameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByUsername.expectations = append(mmGetUserByUsername.expectations, expectation)
	return expectation
}

// Then sets up Facade.GetUserByUsername return parameters for the expectation previously defined by the When method
func (e *FacadeMockGetUserByUsernameExpectation) Then(up1 *dto.UserDto, err error) *FacadeMock {
	e.results = &FacadeMockGetUserByUsernameResults{up1, err}
	return e.mock
}

// Times sets number of times Facade.GetUserByUsername should be invoked
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) Times(n uint64) *mFacadeMockGetUserByUsername {
	if n == 0 {
		mmGetUserByUsername.mock.t.Fatalf("Times of FacadeMock.GetUserByUsername mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByUsername.expectedInvocations, n)
	mmGetUserByUsername.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByUsername
}

func (mmGetUserByUsername *mFacadeMockGetUserByUsername) invocationsDone() bool {
	if len(mmGetUserByUsername.expectations) == 0 && mmGetUserByUsername.defaultExpectation == nil && mmGetUserByUsername.mock.funcGetUserByUsername == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByUsername.mock.afterGetUserByUsernameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByUsername.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByUsername implements mm_repository.Facade
func (mmGetUserByUsername *FacadeMock) GetUserByUsername(ctx context.Context, username string) (up1 *dto.UserDto, err error) {
	mm_atomic.AddUint64(&mmGetUserByUsername.beforeGetUserByUsernameCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByUsername.afterGetUserByUsernameCounter, 1)

	mmGetUserByUsername.t.Helper()

	if mmGetUserByUsername.inspectFuncGetUserByUsername != nil {
		mmGetUserByUsername.inspectFuncGetUserByUsername(ctx, username)
	}

	mm_params := FacadeMockGetUserByUsernameParams{ctx, username}

	// Record call args
	mmGetUserByUsername.GetUserByUsernameMock.mutex.Lock()
	mmGetUserByUsername.GetUserByUsernameMock.callArgs = append(mmGetUserByUsername.GetUserByUsernameMock.callArgs, &mm_params)
	mmGetUserByUsername.GetUserByUsernameMock.mutex.Unlock()

	for _, e := range mmGetUserByUsername.GetUserByUsernameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockGetUserByUsernameParams{ctx, username}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByUsername.t.Errorf("FacadeMock.GetUserByUsername got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.username != nil && !minimock.Equal(*mm_want_ptrs.username, mm_got.username) {
				mmGetUserByUsername.t.Errorf("FacadeMock.GetUserByUsername got unexpected parameter username, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.originUsername, *mm_want_ptrs.username, mm_got.username, minimock.Diff(*mm_want_ptrs.username, mm_got.username))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByUsername.t.Errorf("FacadeMock.GetUserByUsername got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByUsername.GetUserByUsernameMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByUsername.t.Fatal("No results are set for the FacadeMock.GetUserByUsername")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByUsername.funcGetUserByUsername != nil {
		return mmGetUserByUsername.funcGetUserByUsername(ctx, username)
	}
	mmGetUserByUsername.t.Fatalf("Unexpected call to FacadeMock.GetUserByUsername. %v %v", ctx, username)
	return
}

// GetUserByUsernameAfterCounter returns a count of finished FacadeMock.GetUserByUsername invocations
func (mmGetUserByUsername *FacadeMock) GetUserByUsernameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByUsername.afterGetUserByUsernameCounter)
}

// GetUserByUsernameBeforeCounter returns a count of FacadeMock.GetUserByUsername invocations
func (mmGetUserByUsername *FacadeMock) GetUserByUsernameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByUsername.beforeGetUserByUsernameCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.GetUserByUsername.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByUsername *mFacadeMockGetUserByUsername) Calls() []*FacadeMockGetUserByUsernameParams {
	mmGetUserByUsername.mutex.RLock()

	argCopy := make([]*FacadeMockGetUserByUsernameParams, len(mmGetUserByUsername.callArgs))
	copy(argCopy, mmGetUserByUsername.callArgs)

	mmGetUserByUsername.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByUsernameDone returns true if the count of the GetUserByUsername invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockGetUserByUsernameDone() bool {
	if m.GetUserByUsernameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByUsernameMock.invocationsDone()
}

// MinimockGetUserByUsernameInspect logs each unmet expectation
func (m *FacadeMock) MinimockGetUserByUsernameInspect() {
	for _, e := range m.GetUserByUsernameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.GetUserByUsername at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByUsernameCounter := mm_atomic.LoadUint64(&m.afterGetUserByUsernameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByUsernameMock.defaultExpectation != nil && afterGetUserByUsernameCounter < 1 {
		if m.GetUserByUsernameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.GetUserByUsername at\n%s", m.GetUserByUsernameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.GetUserByUsername at\n%s with params: %#v", m.GetUserByUsernameMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByUsernameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByUsername != nil && afterGetUserByUsernameCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.GetUserByUsername at\n%s", m.funcGetUserByUsernameOrigin)
	}

	if !m.GetUserByUsernameMock.invocationsDone() && afterGetUserByUsernameCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.GetUserByUsername at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByUsernameMock.expectedInvocations), m.GetUserByUsernameMock.expectedInvocationsOrigin, afterGetUserByUsernameCounter)
	}
}

type mFacadeMockRefresh struct {
	optional           bool
	mock               *FacadeMock
	defaultExpectation *FacadeMockRefreshExpectation
	expectations       []*FacadeMockRefreshExpectation

	callArgs []*FacadeMockRefreshParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// FacadeMockRefreshExpectation specifies expectation struct of the Facade.Refresh
type FacadeMockRefreshExpectation struct {
	mock               *FacadeMock
	params             *FacadeMockRefreshParams
	paramPtrs          *FacadeMockRefreshParamPtrs
	expectationOrigins FacadeMockRefreshExpectationOrigins
	results            *FacadeMockRefreshResults
	returnOrigin       string
	Counter            uint64
}

// FacadeMockRefreshParams contains parameters of the Facade.Refresh
type FacadeMockRefreshParams struct {
	ctx context.Context
	req dto.UpdateRefreshDto
}

// FacadeMockRefreshParamPtrs contains pointers to parameters of the Facade.Refresh
type FacadeMockRefreshParamPtrs struct {
	ctx *context.Context
	req *dto.UpdateRefreshDto
}

// FacadeMockRefreshResults contains results of the Facade.Refresh
type FacadeMockRefreshResults struct {
	err error
}

// FacadeMockRefreshOrigins contains origins of expectations of the Facade.Refresh
type FacadeMockRefreshExpectationOrigins struct {
	origin    string
	originCtx string
	originReq string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRefresh *mFacadeMockRefresh) Optional() *mFacadeMockRefresh {
	mmRefresh.optional = true
	return mmRefresh
}

// Expect sets up expected params for Facade.Refresh
func (mmRefresh *mFacadeMockRefresh) Expect(ctx context.Context, req dto.UpdateRefreshDto) *mFacadeMockRefresh {
	if mmRefresh.mock.funcRefresh != nil {
		mmRefresh.mock.t.Fatalf("FacadeMock.Refresh mock is already set by Set")
	}

	if mmRefresh.defaultExpectation == nil {
		mmRefresh.defaultExpectation = &FacadeMockRefreshExpectation{}
	}

	if mmRefresh.defaultExpectation.paramPtrs != nil {
		mmRefresh.mock.t.Fatalf("FacadeMock.Refresh mock is already set by ExpectParams functions")
	}

	mmRefresh.defaultExpectation.params = &FacadeMockRefreshParams{ctx, req}
	mmRefresh.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRefresh.expectations {
		if minimock.Equal(e.params, mmRefresh.defaultExpectation.params) {
			mmRefresh.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefresh.defaultExpectation.params)
		}
	}

	return mmRefresh
}

// ExpectCtxParam1 sets up expected param ctx for Facade.Refresh
func (mmRefresh *mFacadeMockRefresh) ExpectCtxParam1(ctx context.Context) *mFacadeMockRefresh {
	if mmRefresh.mock.funcRefresh != nil {
		mmRefresh.mock.t.Fatalf("FacadeMock.Refresh mock is already set by Set")
	}

	if mmRefresh.defaultExpectation == nil {
		mmRefresh.defaultExpectation = &FacadeMockRefreshExpectation{}
	}

	if mmRefresh.defaultExpectation.params != nil {
		mmRefresh.mock.t.Fatalf("FacadeMock.Refresh mock is already set by Expect")
	}

	if mmRefresh.defaultExpectation.paramPtrs == nil {
		mmRefresh.defaultExpectation.paramPtrs = &FacadeMockRefreshParamPtrs{}
	}
	mmRefresh.defaultExpectation.paramPtrs.ctx = &ctx
	mmRefresh.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRefresh
}

// ExpectReqParam2 sets up expected param req for Facade.Refresh
func (mmRefresh *mFacadeMockRefresh) ExpectReqParam2(req dto.UpdateRefreshDto) *mFacadeMockRefresh {
	if mmRefresh.mock.funcRefresh != nil {
		mmRefresh.mock.t.Fatalf("FacadeMock.Refresh mock is already set by Set")
	}

	if mmRefresh.defaultExpectation == nil {
		mmRefresh.defaultExpectation = &FacadeMockRefreshExpectation{}
	}

	if mmRefresh.defaultExpectation.params != nil {
		mmRefresh.mock.t.Fatalf("FacadeMock.Refresh mock is already set by Expect")
	}

	if mmRefresh.defaultExpectation.paramPtrs == nil {
		mmRefresh.defaultExpectation.paramPtrs = &FacadeMockRefreshParamPtrs{}
	}
	mmRefresh.defaultExpectation.paramPtrs.req = &req
	mmRefresh.defaultExpectation.expectationOrigins.originReq = minimock.CallerInfo(1)

	return mmRefresh
}

// Inspect accepts an inspector function that has same arguments as the Facade.Refresh
func (mmRefresh *mFacadeMockRefresh) Inspect(f func(ctx context.Context, req dto.UpdateRefreshDto)) *mFacadeMockRefresh {
	if mmRefresh.mock.inspectFuncRefresh != nil {
		mmRefresh.mock.t.Fatalf("Inspect function is already set for FacadeMock.Refresh")
	}

	mmRefresh.mock.inspectFuncRefresh = f

	return mmRefresh
}

// Return sets up results that will be returned by Facade.Refresh
func (mmRefresh *mFacadeMockRefresh) Return(err error) *FacadeMock {
	if mmRefresh.mock.funcRefresh != nil {
		mmRefresh.mock.t.Fatalf("FacadeMock.Refresh mock is already set by Set")
	}

	if mmRefresh.defaultExpectation == nil {
		mmRefresh.defaultExpectation = &FacadeMockRefreshExpectation{mock: mmRefresh.mock}
	}
	mmRefresh.defaultExpectation.results = &FacadeMockRefreshResults{err}
	mmRefresh.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRefresh.mock
}

// Set uses given function f to mock the Facade.Refresh method
func (mmRefresh *mFacadeMockRefresh) Set(f func(ctx context.Context, req dto.UpdateRefreshDto) (err error)) *FacadeMock {
	if mmRefresh.defaultExpectation != nil {
		mmRefresh.mock.t.Fatalf("Default expectation is already set for the Facade.Refresh method")
	}

	if len(mmRefresh.expectations) > 0 {
		mmRefresh.mock.t.Fatalf("Some expectations are already set for the Facade.Refresh method")
	}

	mmRefresh.mock.funcRefresh = f
	mmRefresh.mock.funcRefreshOrigin = minimock.CallerInfo(1)
	return mmRefresh.mock
}

// When sets expectation for the Facade.Refresh which will trigger the result defined by the following
// Then helper
func (mmRefresh *mFacadeMockRefresh) When(ctx context.Context, req dto.UpdateRefreshDto) *FacadeMockRefreshExpectation {
	if mmRefresh.mock.funcRefresh != nil {
		mmRefresh.mock.t.Fatalf("FacadeMock.Refresh mock is already set by Set")
	}

	expectation := &FacadeMockRefreshExpectation{
		mock:               mmRefresh.mock,
		params:             &FacadeMockRefreshParams{ctx, req},
		expectationOrigins: FacadeMockRefreshExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRefresh.expectations = append(mmRefresh.expectations, expectation)
	return expectation
}

// Then sets up Facade.Refresh return parameters for the expectation previously defined by the When method
func (e *FacadeMockRefreshExpectation) Then(err error) *FacadeMock {
	e.results = &FacadeMockRefreshResults{err}
	return e.mock
}

// Times sets number of times Facade.Refresh should be invoked
func (mmRefresh *mFacadeMockRefresh) Times(n uint64) *mFacadeMockRefresh {
	if n == 0 {
		mmRefresh.mock.t.Fatalf("Times of FacadeMock.Refresh mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRefresh.expectedInvocations, n)
	mmRefresh.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRefresh
}

func (mmRefresh *mFacadeMockRefresh) invocationsDone() bool {
	if len(mmRefresh.expectations) == 0 && mmRefresh.defaultExpectation == nil && mmRefresh.mock.funcRefresh == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRefresh.mock.afterRefreshCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRefresh.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Refresh implements mm_repository.Facade
func (mmRefresh *FacadeMock) Refresh(ctx context.Context, req dto.UpdateRefreshDto) (err error) {
	mm_atomic.AddUint64(&mmRefresh.beforeRefreshCounter, 1)
	defer mm_atomic.AddUint64(&mmRefresh.afterRefreshCounter, 1)

	mmRefresh.t.Helper()

	if mmRefresh.inspectFuncRefresh != nil {
		mmRefresh.inspectFuncRefresh(ctx, req)
	}

	mm_params := FacadeMockRefreshParams{ctx, req}

	// Record call args
	mmRefresh.RefreshMock.mutex.Lock()
	mmRefresh.RefreshMock.callArgs = append(mmRefresh.RefreshMock.callArgs, &mm_params)
	mmRefresh.RefreshMock.mutex.Unlock()

	for _, e := range mmRefresh.RefreshMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRefresh.RefreshMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefresh.RefreshMock.defaultExpectation.Counter, 1)
		mm_want := mmRefresh.RefreshMock.defaultExpectation.params
		mm_want_ptrs := mmRefresh.RefreshMock.defaultExpectation.paramPtrs

		mm_got := FacadeMockRefreshParams{ctx, req}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRefresh.t.Errorf("FacadeMock.Refresh got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefresh.RefreshMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.req != nil && !minimock.Equal(*mm_want_ptrs.req, mm_got.req) {
				mmRefresh.t.Errorf("FacadeMock.Refresh got unexpected parameter req, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefresh.RefreshMock.defaultExpectation.expectationOrigins.originReq, *mm_want_ptrs.req, mm_got.req, minimock.Diff(*mm_want_ptrs.req, mm_got.req))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRefresh.t.Errorf("FacadeMock.Refresh got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRefresh.RefreshMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRefresh.RefreshMock.defaultExpectation.results
		if mm_results == nil {
			mmRefresh.t.Fatal("No results are set for the FacadeMock.Refresh")
		}
		return (*mm_results).err
	}
	if mmRefresh.funcRefresh != nil {
		return mmRefresh.funcRefresh(ctx, req)
	}
	mmRefresh.t.Fatalf("Unexpected call to FacadeMock.Refresh. %v %v", ctx, req)
	return
}

// RefreshAfterCounter returns a count of finished FacadeMock.Refresh invocations
func (mmRefresh *FacadeMock) RefreshAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefresh.afterRefreshCounter)
}

// RefreshBeforeCounter returns a count of FacadeMock.Refresh invocations
func (mmRefresh *FacadeMock) RefreshBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefresh.beforeRefreshCounter)
}

// Calls returns a list of arguments used in each call to FacadeMock.Refresh.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefresh *mFacadeMockRefresh) Calls() []*FacadeMockRefreshParams {
	mmRefresh.mutex.RLock()

	argCopy := make([]*FacadeMockRefreshParams, len(mmRefresh.callArgs))
	copy(argCopy, mmRefresh.callArgs)

	mmRefresh.mutex.RUnlock()

	return argCopy
}

// MinimockRefreshDone returns true if the count of the Refresh invocations corresponds
// the number of defined expectations
func (m *FacadeMock) MinimockRefreshDone() bool {
	if m.RefreshMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RefreshMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RefreshMock.invocationsDone()
}

// MinimockRefreshInspect logs each unmet expectation
func (m *FacadeMock) MinimockRefreshInspect() {
	for _, e := range m.RefreshMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FacadeMock.Refresh at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRefreshCounter := mm_atomic.LoadUint64(&m.afterRefreshCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshMock.defaultExpectation != nil && afterRefreshCounter < 1 {
		if m.RefreshMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to FacadeMock.Refresh at\n%s", m.RefreshMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to FacadeMock.Refresh at\n%s with params: %#v", m.RefreshMock.defaultExpectation.expectationOrigins.origin, *m.RefreshMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefresh != nil && afterRefreshCounter < 1 {
		m.t.Errorf("Expected call to FacadeMock.Refresh at\n%s", m.funcRefreshOrigin)
	}

	if !m.RefreshMock.invocationsDone() && afterRefreshCounter > 0 {
		m.t.Errorf("Expected %d calls to FacadeMock.Refresh at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RefreshMock.expectedInvocations), m.RefreshMock.expectedInvocationsOrigin, afterRefreshCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FacadeMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddAssetInspect()

			m.MinimockAddRefreshSessionInspect()

			m.MinimockAddUserInspect()

			m.MinimockDeleteAssetInspect()

			m.MinimockGetAssetInfoInspect()

			m.MinimockGetUserByUsernameInspect()

			m.MinimockRefreshInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FacadeMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FacadeMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddAssetDone() &&
		m.MinimockAddRefreshSessionDone() &&
		m.MinimockAddUserDone() &&
		m.MinimockDeleteAssetDone() &&
		m.MinimockGetAssetInfoDone() &&
		m.MinimockGetUserByUsernameDone() &&
		m.MinimockRefreshDone()
}
